I"’<h1 id="event--driven-architecture">Event -Driven Architecture</h1>

<p><img src="./../kaynaklar/sync-async.png" alt="Senkron ve Asenkron iletiÅŸim" /></p>

<p><strong>Senkron</strong>: Synchronous communication (senkron iletiÅŸim), bir veri alÄ±ÅŸveriÅŸi iÅŸleminin iki taraf arasÄ±nda gerÃ§ek zamanlÄ± olarak gerÃ§ekleÅŸtirildiÄŸi bir iletiÅŸim yÃ¶ntemidir. Ä°ki taraf arasÄ±nda belirli bir sÄ±rayla ve zamanlama ile bilgi alÄ±ÅŸveriÅŸi yapÄ±lÄ±r.Bu iletiÅŸim yÃ¶nteminde, veri gÃ¶nderen taraf, veriyi gÃ¶ndermeden Ã¶nce veri alÄ±cÄ± tarafÄ±n hazÄ±r olduÄŸunu doÄŸrulamak iÃ§in bekler. Veri alÄ±cÄ± taraf, veri gÃ¶nderen tarafÄ±n iÅŸlemi tamamlamasÄ±nÄ± bekler ve ardÄ±ndan yanÄ±t verir. Senkron iletiÅŸimde, veri gÃ¶nderme iÅŸlemi tamamlanmadan Ã¶nce veri alÄ±ÅŸveriÅŸi tamamlanmaz.</p>

<p>Senkron iletiÅŸimde, veri alÄ±ÅŸveriÅŸi iÅŸleminin bir tarafÄ±ndan kaynaklanan bir gecikme, diÄŸer taraftaki iÅŸlemi geciktirebilir. Bu nedenle, yÃ¼ksek trafikli uygulamalarda senkron iletiÅŸim yerine, asenkron iletiÅŸim tercih edilmelidir.</p>

<p><strong>Asenkron</strong>: Veri alÄ±ÅŸveriÅŸinde gerÃ§ek zamanlÄ± olmayan bir iletiÅŸim yÃ¶ntemidir.Asenkron mesaj bize scability,reciliency ve High availability saÄŸlar.</p>

<p><strong>Event-driven architecture (EDA)</strong>: Etkinlik temelli mimari anlamÄ±na gelir. Bu mimari, bir sistemdeki bileÅŸenlerin birbirleriyle iletiÅŸim kurmasÄ±nÄ± ve iÅŸlemlerini olaylara (event) yanÄ±t olarak gerÃ§ekleÅŸtirmesini saÄŸlar.EDA, birÃ§ok farklÄ± bileÅŸenin etkileÅŸim iÃ§inde olduÄŸu karmaÅŸÄ±k sistemlerde kullanÄ±lÄ±r. Bu bileÅŸenler, birbirleriyle doÄŸrudan iletiÅŸim kurmak yerine, bir aracÄ± olarak hareket eden bir olay akÄ±ÅŸÄ± (event stream) Ã¼zerinden iletiÅŸim kurarlar. Bu sayede, bir bileÅŸenin diÄŸer bir bileÅŸenin durumunu sÃ¼rekli olarak takip etmesi yerine, olaylarÄ±n oluÅŸmasÄ± durumunda olay akÄ±ÅŸÄ±ndan gelen bilgiyi kullanarak ilgili iÅŸlemi gerÃ§ekleÅŸtirir.</p>

<ul>
  <li>Publish/Subscribe Pattern: Bu pattern, bir veya daha fazla kaynaktan gelen olaylarÄ± dinleyen ve olaylarÄ±n iÅŸlenmesi iÃ§in bir veya daha fazla tÃ¼keticinin kaydolduÄŸu bir yayÄ±n kanalÄ± kullanÄ±r. Bu sayede kaynaklar ve tÃ¼keticiler arasÄ±ndaki baÄŸÄ±mlÄ±lÄ±k azaltÄ±larak uygulamanÄ±n Ã¶lÃ§eklenebilirliÄŸi artÄ±rÄ±lÄ±r.</li>
  <li>Event Sourcing Pattern: Bu pattern, uygulamanÄ±n durumunu ve Ã¶nceki iÅŸlemlerini takip etmek iÃ§in olaylarÄ±n kaydedilmesini kullanÄ±r. Bu ÅŸekilde uygulamanÄ±n mevcut durumu, geÃ§miÅŸ olaylarÄ±n birleÅŸtirilmesiyle elde edilir. Bu pattern, uygulamalarÄ±n Ã¶lÃ§eklenebilirliÄŸini artÄ±rÄ±r ve aynÄ± zamanda kaynaklarÄ±n anlÄ±k durumunu kaydetme konusunda daha esnek olmalarÄ±na olanak tanÄ±r.</li>
  <li>CQRS (Command Query Responsibility Segregation) Pattern: Bu pattern, okuma iÅŸlemlerinin yazma iÅŸlemlerinden ayrÄ±lmasÄ±nÄ± ve bunlarÄ±n farklÄ± uygulama katmanlarÄ±nda ele alÄ±nmasÄ±nÄ± saÄŸlar. Bu, uygulamalarÄ±n Ã¶lÃ§eklenebilirliÄŸini artÄ±rÄ±r ve aynÄ± zamanda farklÄ± iÅŸlemlere farklÄ± hizmet dÃ¼zeyleri sunmalarÄ±na olanak tanÄ±r.</li>
  <li>Sagas Pattern: Bu pattern, uzun Ã¶mÃ¼rlÃ¼ ve karmaÅŸÄ±k iÅŸ akÄ±ÅŸlarÄ±na sahip uygulamalar iÃ§in kullanÄ±lÄ±r. Bu pattern, iÅŸ akÄ±ÅŸÄ±ndaki her adÄ±mda bir olayÄ±n tetiklenmesi ve bir sonraki adÄ±mda hangi iÅŸlemin gerÃ§ekleÅŸtirileceÄŸine karar verilmesiyle Ã§alÄ±ÅŸÄ±r. Bu, uygulamalarÄ±n daha karmaÅŸÄ±k senaryolarda Ã§alÄ±ÅŸmasÄ±na olanak tanÄ±r.</li>
</ul>

<h2 id="publishsubscribe-pattern">Publish/Subscribe Pattern</h2>

<p>Servisler arasÄ± haberleÅŸmenin event mesajlar Ã¼zerinden asenkron ÅŸekilde yapÄ±lmasÄ±nÄ± saÄŸlamaktadÄ±r. FIFO(first in first out) ilk giren ilk Ã§Ä±kacak ÅŸekildedir
Publisher mesajlarÄ± Ã¼retip gÃ¶nderirken Subscribers ise mesajÄ± tÃ¼ketmek ile sorumludur.</p>
:ET